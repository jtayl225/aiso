// import 'dart:convert';
import 'package:aiso/models/cadence_enum.dart';
import 'package:aiso/models/db_timestamps_model.dart';
import 'package:aiso/models/entity_model.dart';
import 'package:aiso/models/industry_model.dart';
import 'package:aiso/models/location_models.dart';
import 'package:aiso/models/prompt_model.dart';
import 'package:aiso/models/search_target_model.dart';
import 'package:aiso/reports/models/report_model.dart';
import 'package:aiso/services/location_service_supabase.dart';
import 'package:aiso/services/report_service_supabase.dart';
import 'package:aiso/utils/logger.dart';
// import 'package:crypto/crypto.dart';
import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

/// A ChangeNotifier ViewModel to handle state & logic for the FreeReport flow.
/// It listens to supabase realtime on report_runs for status updates,
/// and drives both timeline and result screens.
class FreeReportViewModel extends ChangeNotifier {

  final ReportServiceSupabase _reportService = ReportServiceSupabase();
  final LocationServiceSupabase _locationService = LocationServiceSupabase();

  bool isLoading = false;
  String? errorMessage;

  String email = '';
  String entityBusinessName = '';
  String entityPersonName = '';
  String prompt = '';
  String reportId = '';
  String promptText = '';

  List<Entity> _entities = [];
  List<Entity> get entities => _entities;
  set entities(List<Entity> value) {
    _entities = value;
    notifyListeners();
  }

  List<Industry> industries = [];
  Industry? selectedIndustry;

  List<Country> countries = [];
  Country? _selectedCountry;
  Country? get selectedCountry => _selectedCountry;
  set selectedCountry(Country? value) {
    _selectedCountry = value;
    selectedRegion = null; // Reset selected region if country changes
    notifyListeners(); // ✅ Trigger UI rebuild
  }

  Region? _selectedRegion;
  Region? get selectedRegion => _selectedRegion;
  set selectedRegion(Region? value) {
    _selectedRegion = value;
    notifyListeners();
  }

  Locality? _selectedLocality;
  Locality? get selectedLocality => _selectedLocality;
  set selectedLocality(Locality? value) {
    _selectedLocality = value;
    notifyListeners();
  }

  bool get isFormValid => 
    email.isNotEmpty &&
    email.contains('@') &&
    selectedIndustry != null && 
    entityBusinessName.isNotEmpty &&
    _selectedCountry != null &&
    _selectedRegion != null &&
    _selectedLocality != null;

  FreeReportViewModel() {
    Future.microtask(() => init());
  }


  Future<void> init() async {

    // Defer first notification to avoid "called during build"
    Future.microtask(() {
      isLoading = true;
      errorMessage = null;
      notifyListeners();
    });

    try {
      countries = await _locationService.fetchCountries();
      selectedCountry = countries.first;
      industries = await _reportService.fetchIndustries();
      selectedIndustry = industries.first;
    } catch (e) {
      errorMessage = 'Failed to initialize: $e';
    } finally {
      // Defer again to ensure build is complete
      Future.microtask(() {
        isLoading = false;
        notifyListeners();
      });
    }
  }


  void _handleError(Object error, [StackTrace? stackTrace]) {
    errorMessage = error.toString();

    debugPrint('FreeReportViewModel error: $errorMessage');
    
    if (stackTrace != null) {
      debugPrint('Stack trace:\n$stackTrace');
    }

    // You can add extra error handling logic here, like:
    // - showing user-friendly messages
    // - sending logs to remote error tracking services
  }

  // String _hashString(String value) {
  //     final normalized = value.trim().toLowerCase();
  //     final bytes = utf8.encode(normalized);
  //     final digest = sha256.convert(bytes);
  //     return digest.toString();
  //   }

  /// createAndRunFreeReport
  Report _buildFreeReport() {

    final Report freeReport = Report(
      id: '', // generated by supabase
      userId: '', // generated by supabase
      searchTargetId: '', // generated by supabase
      title: 'Free report!',
      isPaid: false,
      cadence: Cadence.once,
      dbTimestamps: DbTimestamps.now(),
    );

    return freeReport;

  }

  SearchTarget _buildSearchTarget() {

    final String targetName = entityPersonName.isNotEmpty ? entityPersonName : entityBusinessName;
    final String targetDescription = entityPersonName.isNotEmpty ? 'Real estate agent at $entityBusinessName' : 'A real estate agency.';
    final EntityType targetEntityType = entityPersonName.isNotEmpty ? EntityType.person : EntityType.business;

    final SearchTarget searchTarget = SearchTarget(
      id: '', // generated by supabase
      // reportId: reportId,
      userId: '',
      name: targetName, 
      entityType: targetEntityType, 
      industry: selectedIndustry!,
      description: targetDescription, 
      dbTimestamps: DbTimestamps.now()
      );

    return searchTarget;

  }

  String _buildPromptText(String basePrompt) {
    if (selectedLocality == null || selectedRegion == null || selectedCountry == null) {
      throw StateError('All location fields must be selected');
    }

    return '$basePrompt in ${selectedLocality!.name}, ${selectedRegion!.code} ${selectedCountry!.name}';
  }

  Prompt _buildPrompt(String promptText) {
    return Prompt(id: '', localityId: selectedLocality?.id, prompt: promptText, dbTimestamps: DbTimestamps.now());
  }

  Future<bool> processFreeReport() async {
    isLoading = true;
    notifyListeners();
    try {
      printDebug('[processFreeReport]');

      final SearchTarget searchTarget = _buildSearchTarget();
      final Report report = _buildFreeReport();
      final Prompt prompt = _buildPrompt(_buildPromptText('Top 10 real estate agencies'));

      final String? _ = await _reportService.processFreeReport(email, prompt, searchTarget, report);
      
      return true;
    } catch (e) {
      _handleError(e);
      return false;
    } finally {
      isLoading = false;
      notifyListeners();
    }
  }

  Future<void> fetchCountries() async {
    isLoading = true;
    notifyListeners();
    try {
      countries = await _locationService.fetchCountries();
    } catch (e) {
      _handleError(e);
    } finally {
      isLoading = false;
      notifyListeners();
    }
  }

  // Future<Locality?> fetchLocality(String regionIsoCode, String localityName) async {
  //   // 1) show loading
  //   isLoading = true;
  //   notifyListeners();
  //   try {
  //     debugPrint('DEBUG: createAndRunFreeReport.');

  //     // 2) compute normalized hash
  //     final String localityHash = _hashString(regionIsoCode + localityName);

  //     // 3) attempt to fetch an existing one
  //     final Locality? existingLocality = await _reportService.fetchLocalityFromHash(localityHash);
  //     if (existingLocality != null) return existingLocality;

  //     // // 4) not found → correct spelling via ChatGPT
  //     // final String correctedName = await _reportService.correctLocalityName(
  //     //   regionIsoCode: regionIsoCode,
  //     //   rawName: localityName,
  //     // );

  //     // // 5) geocode the corrected name
  //     // final LatLng coords = await _reportService.geocodeLocality(
  //     //   regionIsoCode: regionIsoCode,
  //     //   localityName: correctedName,
  //     // );

  //     // // 6) assemble a new Locality instance (id blank—server will fill it)
  //     // final newLocality = Locality(
  //     //   id: '', 
  //     //   countryAlpha2: '', 
  //     //   countryAlpha3: '', 
  //     //   countryName: '',
  //     //   regionCode: '',
  //     //   regionIsoCode: regionIsoCode,
  //     //   regionName: '',
  //     //   name: correctedName,
  //     //   latitude: coords.latitude,
  //     //   longitude: coords.longitude,
  //     // );

  //     // // 7) persist via your service & return the result
  //     // final Locality created = await _reportService.createLocality(newLocality);
  //     // return created;

  //   } catch (e) {
  //     _handleError(e);
  //     return null;
  //   } finally {
  //     isLoading = false;
  //     notifyListeners();
  //   }
  // }

  /// Returns up to 3 matching localities for the given input
  Future<List<Locality>> fetchLocalitySuggestions(String pattern) async {
    debugPrint('fetchLocalitySuggestions called with: "$pattern"');

    final trimmed = pattern.trim();
    if (trimmed.isEmpty) return [];
    if (selectedRegion == null) return [];

    final response = await Supabase.instance.client
        .from('localities')
        .select('id, region_iso_code, name, latitude, longitude')
        .eq('region_iso_code', selectedRegion!.isoCode)
        .ilike('name', '%$trimmed%')
        .limit(3);

    final List<Locality> localities = (response as List).map((item) {
      return Locality.fromJson(item);
    }).toList();

    return localities;

  }

}